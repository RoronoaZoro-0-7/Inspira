// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Use Postgres for transactions & constraints
  url      = env("DATABASE_URL")
}

//
// ============= Enums =============
//

enum Role {
  USER
  MODERATOR
  ADMIN
}


enum CreditTxType {
  STARTER_GRANT // initial credits on signup
  POST_COST // cost to publish a question
  HELPFUL_REWARD // reward to answerer
  PURCHASE // user buys credits with fiat
  ADJUSTMENT // admin/manual correction
}

//
// ============= Models =============
//

model User {
  id        String   @id @default(cuid())
  clerkId   String   @unique
  email     String   @unique
  role      Role     @default(USER)
  profileId String?  @unique // Optional foreign key to Profile, must be unique for 1:1
  profile   Profile? @relation(fields: [profileId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role])
  @@index([createdAt])
}

model Profile {
  id       String  @id @default(cuid())
  userId   String  @unique
  user     User?

  name     String?
  imageUrl String?
  bio      String?
  credits  Int     @default(0)
  expertiseTags String[] @default([])
  interestTags  String[] @default([])

  // Direct relations to Profile (author/user fields)
  authoredPosts    Post[]           @relation("PostAuthor")
  authoredComments Comment[]        @relation("CommentAuthor")
  postUpvotes      PostUpvote[]     @relation("UserPostUpvotes")
  commentUpvotes   CommentUpvote[]  @relation("UserCommentUpvotes")
  markedHelpful    HelpfulMark[]    @relation("MarkedBy")
  creditTxs        CreditTransaction[] @relation("UserCreditTxs")

  // Chat relations
  conversationsAsParticipant1 ChatConversation[] @relation("ChatParticipant1")
  conversationsAsParticipant2 ChatConversation[] @relation("ChatParticipant2")
  sentMessages               ChatMessage[]       @relation("ChatMessageSender")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Category {
  id   String @id @default(cuid())
  slug String @unique // "coding", "design", etc.
  name String

  posts Post[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id       String  @id @default(cuid())
  authorId String
  author   Profile   @relation("PostAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  categoryIds String[]
  categories Category[]

  title      String
  content    String? // plain text content
  imageUrls  String[] @default([]) // multiple image URLs
  videoUrls  String[] @default([]) // multiple video URLs

  // Optional denormalized pointer for quick reads
  helpfulCommentIds String[] // can store multiple helpful comment IDs

  comments    Comment[]
  upvotes     PostUpvote[]
  helpfulMark HelpfulMark? // 1:1 via postId unique in HelpfulMark

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  CreditTransaction CreditTransaction[]

  @@index([authorId, createdAt])
  @@index([categoryIds, createdAt])
}

model Comment {
  id String @id @default(cuid())

  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  authorId String
  author   Profile   @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  content String

  // Self-relation for nested replies
  parentId String?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("CommentReplies")

  upvotes    CommentUpvote[]
  helpfulFor HelpfulMark? // if this comment was marked helpful for its post

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  CreditTransaction CreditTransaction[]

  @@index([postId, createdAt])
  @@index([authorId, createdAt])
  @@index([parentId])
}

//
// One free upvote per (user, post)
//
model PostUpvote {
  id     String @id @default(cuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  userId String
  user   Profile   @relation("UserPostUpvotes", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

@@unique([postId, userId]) // prevents duplicate upvotes
  @@index([userId, createdAt])
}

//
// One free upvote per (user, comment)
//
model CommentUpvote {
  id        String  @id @default(cuid())
  commentId String
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  userId String
  user   Profile   @relation("UserCommentUpvotes", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([commentId, userId]) // prevents duplicate upvotes
  @@index([userId, createdAt])
}

//
// Exactly one helpful mark per post.
// Enforce with unique(postId). App logic must also ensure only the post author can mark.
// When created, you should atomically:
// - transfer credits from post.author to comment.author (helpfulReward)
// - set post.helpfulCommentId
//
model HelpfulMark {
  id String @id @default(cuid())

  postId String @unique
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  commentId String  @unique
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  markedById String // should equal post.authorId (enforce in app logic/SQL trigger if you want)
  markedBy   Profile   @relation("MarkedBy", fields: [markedById], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([markedById, createdAt])
}

//
// Immutable ledger of all credit changes.
// Keep User.credits consistent by wrapping writes in transactions:
// - Insert ledger row(s)
// - Update User.credits deltas
// - Optionally assert non-negative balance before commit
//
model CreditTransaction {
  id String @id @default(cuid())

  userId String
  user   Profile   @relation("UserCreditTxs", fields: [userId], references: [id], onDelete: Cascade)

  type         CreditTxType
  delta        Int // + adds credits; - spends credits
  balanceAfter Int? // optional snapshot for audits

  // Optional references for traceability
  postId String?
  post   Post?   @relation(fields: [postId], references: [id], onDelete: SetNull)

  commentId String?
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: SetNull)

  notes String?

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([type, createdAt])
  @@index([postId])
  @@index([commentId])
}

//
// Chat functionality for direct messaging between users
//

// Chat conversation between two users
model ChatConversation {
  id String @id @default(cuid())

  // Participants in the conversation
  participant1Id String
  participant1   Profile @relation("ChatParticipant1", fields: [participant1Id], references: [id], onDelete: Cascade)

  participant2Id String
  participant2   Profile @relation("ChatParticipant2", fields: [participant2Id], references: [id], onDelete: Cascade)

  // Messages in this conversation
  messages ChatMessage[]

  // Last message for quick access
  lastMessageId String?
  lastMessage   ChatMessage? @relation("LastMessage", fields: [lastMessageId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ensure unique conversation between two users
  @@unique([participant1Id, participant2Id])
  @@index([participant1Id, updatedAt])
  @@index([participant2Id, updatedAt])
}

// Individual chat messages
model ChatMessage {
  id String @id @default(cuid())

  conversationId String
  conversation   ChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId String
  sender   Profile @relation("ChatMessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  content     String
  messageType MessageType @default(TEXT)
  fileUrl     String? // For file/image messages

  // Message status
  isRead      Boolean @default(false)
  readAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations for last message
  conversationAsLastMessage ChatConversation[] @relation("LastMessage")

  @@index([conversationId, createdAt])
  @@index([senderId, createdAt])
}

// Message types
enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}