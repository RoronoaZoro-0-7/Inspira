// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Use Postgres for transactions & constraints
  url      = env("DATABASE_URL")
}

//
// ============= Enums =============
//

enum Role {
  USER
  MODERATOR
  ADMIN
}


enum CreditTxType {
  STARTER_GRANT // initial credits on signup
  POST_COST // cost to publish a question
  HELPFUL_REWARD // reward to answerer
  PURCHASE // user buys credits with fiat
  ADJUSTMENT // admin/manual correction
}

//
// ============= Models =============
//

model User {
  id      String @id @default(cuid())
  clerkId String @unique
  email   String @unique
  role    Role   @default(USER)

  profile Profile?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role])
  @@index([createdAt])
}

model Profile {
  id       String  @id @default(cuid())
  userId   String  @unique
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  name     String?
  imageUrl String?
  bio      String?
  credits  Int     @default(0)
  expertiseTags String[] @default([])
  interestTags  String[] @default([])

  posts Post[]
  comments       Comment[]
  postUpvotes    PostUpvote[]
  commentUpvotes CommentUpvote[]
  helpfulMarks   HelpfulMark[]   @relation("MarkedBy")
  creditTxs      CreditTransaction[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Category {
  id   String @id @default(cuid())
  slug String @unique // "coding", "design", etc.
  name String

  posts Post[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id       String @id @default(cuid())
  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  categoryIds String[]
  categories Category[]

  title      String
  content    String? // plain text content
  imageUrls  String[] @default([]) // multiple image URLs
  videoUrls  String[] @default([]) // multiple video URLs

  // Optional denormalized pointer for quick reads
  helpfulCommentIds String[] // can store multiple helpful comment IDs

  comments    Comment[]
  upvotes     PostUpvote[]
  helpfulMark HelpfulMark? // 1:1 via postId unique in HelpfulMark

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  CreditTransaction CreditTransaction[]

  @@index([authorId, createdAt])
  @@index([categoryId, createdAt])
}

model Comment {
  id String @id @default(cuid())

  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  content String

  // Self-relation for nested replies
  parentId String?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("CommentReplies")

  upvotes    CommentUpvote[]
  helpfulFor HelpfulMark? // if this comment was marked helpful for its post

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  CreditTransaction CreditTransaction[]

  @@index([postId, createdAt])
  @@index([authorId, createdAt])
  @@index([parentId])
}

//
// One free upvote per (user, post)
//
model PostUpvote {
  id     String @id @default(cuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

@@unique([postId, userId]) // prevents duplicate upvotes
  @@index([userId, createdAt])
}

//
// One free upvote per (user, comment)
//
model CommentUpvote {
  id        String  @id @default(cuid())
  commentId String
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([commentId, userId]) // prevents duplicate upvotes
  @@index([userId, createdAt])
}

//
// Exactly one helpful mark per post.
// Enforce with unique(postId). App logic must also ensure only the post author can mark.
// When created, you should atomically:
// - transfer credits from post.author to comment.author (helpfulReward)
// - set post.helpfulCommentId
//
model HelpfulMark {
  id String @id @default(cuid())

  postId String @unique
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  commentId String  @unique
  comment   Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  markedById String // should equal post.authorId (enforce in app logic/SQL trigger if you want)
  markedBy   User   @relation("MarkedBy", fields: [markedById], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([markedById, createdAt])
}

//
// Immutable ledger of all credit changes.
// Keep User.credits consistent by wrapping writes in transactions:
// - Insert ledger row(s)
// - Update User.credits deltas
// - Optionally assert non-negative balance before commit
//
model CreditTransaction {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type         CreditTxType
  delta        Int // + adds credits; - spends credits
  balanceAfter Int? // optional snapshot for audits

  // Optional references for traceability
  postId String?
  post   Post?   @relation(fields: [postId], references: [id], onDelete: SetNull)

  commentId String?
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: SetNull)

  notes String?

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([type, createdAt])
  @@index([postId])
  @@index([commentId])
}